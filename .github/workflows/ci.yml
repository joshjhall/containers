name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - 'auto-patch/**'
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # =====================================
  # Test Stage
  # =====================================
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for Gitleaks to scan commit ranges

      - name: Run unit tests
        run: |
          echo "Running unit tests without Docker..."
          export SKIP_DOCKER_CHECK=true
          ./tests/run_unit_tests.sh

      - name: Run shellcheck
        run: |
          echo "Running shellcheck code quality checks..."
          sudo apt-get update && sudo apt-get install -y shellcheck

          # Run shellcheck on ALL tracked shell scripts (respects .gitignore)
          # Uses --severity=warning to check warnings and errors only (not info/style)
          # Matches the pre-push git hook configuration for consistency
          # Fails the build if any warnings or errors are found
          FAILED=0
          while IFS= read -r file; do
            echo "Checking $file..."
            if ! shellcheck --severity=warning "$file"; then
              FAILED=1
            fi
          done < <(git ls-files '*.sh' '*.bash' 2>/dev/null || \
            find . -type f \( -name "*.sh" -o -name "*.bash" \) \
              ! -path "./.git/*" \
              ! -path "*/node_modules/*" \
              ! -path "*/vendor/*")

          if [ $FAILED -eq 1 ]; then
            echo "❌ Shellcheck found issues in shell scripts."
            exit 1
          fi

          echo "✅ All shell scripts passed shellcheck"

      - name: Run YAML validation
        run: |
          echo "Running YAML validation..."
          pip install yamllint

          # Find all YAML files (exclude .github/ workflows)
          yaml_files=$(git ls-files '*.yml' '*.yaml' | grep -v '^\.github/')

          if [ -z "$yaml_files" ]; then
            echo "No YAML files found"
            exit 0
          fi

          FAILED=0
          while IFS= read -r file; do
            echo "Validating $file..."
            # yamllint returns 0 for success, 1 for warnings, 2 for errors
            # We only fail on errors (exit code 2)
            yamllint -c .yamllint.yml "$file"
            exit_code=$?
            if [ $exit_code -eq 2 ]; then
              FAILED=1
            fi
          done <<< "$yaml_files"

          if [ $FAILED -eq 1 ]; then
            echo "❌ YAML validation failed with errors"
            exit 1
          fi

          echo "✅ All YAML files passed validation (warnings allowed)"

      - name: Run Docker Compose validation
        run: |
          echo "Running Docker Compose validation..."

          # Check if docker-compose is installed
          if ! command -v docker-compose &> /dev/null; then
            echo "⚠️  docker-compose not installed, skipping Docker Compose validation"
            exit 0
          fi

          # Find all docker-compose files
          compose_files=$(git ls-files '*docker-compose*.yml' '*docker-compose*.yaml' '*compose*.yml' '*compose*.yaml' || true)

          if [ -z "$compose_files" ]; then
            echo "✅ No Docker Compose files found"
            exit 0
          fi

          FAILED=0
          while IFS= read -r file; do
            echo "Validating $file..."
            if ! docker-compose -f "$file" config > /dev/null 2>&1; then
              echo "❌ Failed to validate $file"
              docker-compose -f "$file" config 2>&1 || true
              FAILED=1
            fi
          done <<< "$compose_files"

          if [ $FAILED -eq 1 ]; then
            echo "❌ Docker Compose validation failed"
            exit 1
          fi

          echo "✅ All Docker Compose files passed validation"

      - name: Run Markdown linting
        run: |
          echo "Running Markdown linting..."
          pip install pymarkdownlnt

          # Find all markdown files (exclude CHANGELOG.md which is auto-generated)
          md_files=$(git ls-files '*.md' | grep -v '^CHANGELOG\.md$' || true)

          if [ -z "$md_files" ]; then
            echo "✅ No Markdown files found"
            exit 0
          fi

          # Run pymarkdown with disabled rules matching pre-commit config
          # MD013: Line length (too strict for prose with long URLs/paths)
          # MD029: Ordered list prefix (bibliographies use intentional numbering)
          # MD036: Emphasis as heading (conflicts with mdformat auto-formatting)
          # MD041: First line heading (not always applicable for partial docs)
          pymarkdown --disable-rules MD013,MD029,MD036,MD041 scan $md_files

          echo "✅ All Markdown files passed linting"

      - name: Run secret scanning with Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}
        # Note: gitleaks-action@v2 doesn't accept input parameters
        # It automatically scans commits in push/PR events
        # To customize behavior, create a .gitleaks.toml configuration file

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: tests/results/
          retention-days: 7

  # =====================================
  # Build Stage
  # =====================================
  build:
    name: Build Images
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        variant:
          # =====================================================
          # VARIANT FEATURE TOGGLE (for debugging/development)
          # =====================================================
          # To test incrementally, comment out variants below.
          # Start with minimal, then add python-dev, node-dev,
          # cloud-ops, polyglot, and rust-golang one at a time.
          # Once all are working, uncomment all for full testing.
          # =====================================================
          - name: minimal
            build_args: |
              PROJECT_NAME=containers
              PROJECT_PATH=.
          - name: python-dev
            build_args: |
              PROJECT_NAME=containers
              PROJECT_PATH=.
              INCLUDE_PYTHON_DEV=true
              INCLUDE_OP=true
              INCLUDE_DEV_TOOLS=true
              INCLUDE_POSTGRES_CLIENT=true
              INCLUDE_REDIS_CLIENT=true
              INCLUDE_SQLITE_CLIENT=true
              INCLUDE_DOCKER=true
          - name: node-dev
            build_args: |
              PROJECT_NAME=containers
              PROJECT_PATH=.
              INCLUDE_NODE_DEV=true
              INCLUDE_OP=true
              INCLUDE_DEV_TOOLS=true
              INCLUDE_POSTGRES_CLIENT=true
              INCLUDE_REDIS_CLIENT=true
              INCLUDE_SQLITE_CLIENT=true
              INCLUDE_DOCKER=true
          - name: cloud-ops
            build_args: |
              PROJECT_NAME=containers
              PROJECT_PATH=.
              INCLUDE_KUBERNETES=true
              INCLUDE_TERRAFORM=true
              INCLUDE_AWS=true
              INCLUDE_GCLOUD=true
              INCLUDE_CLOUDFLARE=true
              INCLUDE_DEV_TOOLS=true
              INCLUDE_DOCKER=true
              INCLUDE_OP=true
          - name: polyglot
            build_args: |
              PROJECT_NAME=containers
              PROJECT_PATH=.
              INCLUDE_PYTHON_DEV=true
              INCLUDE_NODE_DEV=true
              INCLUDE_DEV_TOOLS=true
              INCLUDE_DOCKER=true
              INCLUDE_OP=true
              INCLUDE_POSTGRES_CLIENT=true
              INCLUDE_REDIS_CLIENT=true
              INCLUDE_SQLITE_CLIENT=true
          - name: rust-golang
            build_args: |
              PROJECT_NAME=containers
              PROJECT_PATH=.
              INCLUDE_RUST_DEV=true
              INCLUDE_GOLANG_DEV=true
          - name: r-dev
            build_args: |
              PROJECT_NAME=containers
              PROJECT_PATH=.
              INCLUDE_R_DEV=true
          - name: production
            build_args: |
              PROJECT_NAME=containers
              PROJECT_PATH=.
              BASE_IMAGE=debian:bookworm-slim
              ENABLE_PASSWORDLESS_SUDO=false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch,suffix=-${{ matrix.variant.name }}
            type=ref,event=tag,suffix=-${{ matrix.variant.name }}
            type=sha,prefix=sha-,suffix=-${{ matrix.variant.name }},enable=false
            type=raw,value=${{ matrix.variant.name }}-latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: ${{ matrix.variant.build_args }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # =====================================
  # Integration Tests
  # =====================================
  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: read
      packages: read
    strategy:
      fail-fast: false
      matrix:
        variant:
          # =====================================================
          # VARIANT FEATURE TOGGLE (for debugging/development)
          # =====================================================
          # Must match enabled variants in the 'build' job above.
          # Only test variants that were successfully built.
          # =====================================================
          - name: minimal
            test: minimal
          - name: python-dev
            test: python_dev
          - name: node-dev
            test: node_dev
          - name: cloud-ops
            test: cloud_ops
          - name: polyglot
            test: polyglot
          - name: rust-golang
            test: rust_golang
          - name: r-dev
            test: r_dev
          - name: production
            test: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull and test image
        run: |
          echo "Testing ${{ matrix.variant.name }} image from registry..."
          # Sanitize branch name (replace / with -) to match docker/metadata-action behavior
          TAG_NAME="${{ github.ref_name }}"
          TAG_NAME="${TAG_NAME//\//-}"
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG_NAME}-${{ matrix.variant.name }}"

          echo "Pulling image: $IMAGE"
          docker pull "$IMAGE"

          echo "Running integration test for ${{ matrix.variant.name }}..."
          IMAGE_TO_TEST="$IMAGE" ./tests/run_integration_tests.sh ${{ matrix.variant.test }}

      - name: Test shell completions
        run: |
          echo "Testing shell completions for ${{ matrix.variant.name }}..."
          TAG_NAME="${{ github.ref_name }}"
          TAG_NAME="${TAG_NAME//\//-}"
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG_NAME}-${{ matrix.variant.name }}"

          # Run shell completion tests inside container
          docker run --rm "$IMAGE" test-completions --verbose || {
            echo "⚠️  Some completion tests failed (non-blocking)"
            # Don't fail the build for completion issues, just warn
            true
          }

      - name: Upload integration test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results-${{ matrix.variant.name }}
          path: tests/results/
          retention-days: 7

  # =====================================
  # Debian Version Compatibility Tests
  # =====================================
  debian-version-test:
    name: Debian Version Compatibility
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        debian:
          - version: "11"
            codename: bullseye
          - version: "12"
            codename: bookworm
          - version: "13"
            codename: trixie
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Test Python build on Debian ${{ matrix.debian.version }}
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: test-debian-${{ matrix.debian.version }}:python
          build-args: |
            BASE_IMAGE=debian:${{ matrix.debian.codename }}-slim
            PROJECT_NAME=test-debian-${{ matrix.debian.version }}
            PROJECT_PATH=.
            INCLUDE_PYTHON_DEV=true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify Python installation
        run: |
          docker run --rm test-debian-${{ matrix.debian.version }}:python python --version
          docker run --rm test-debian-${{ matrix.debian.version }}:python poetry --version

      - name: Test cloud tools on Debian ${{ matrix.debian.version }}
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: test-debian-${{ matrix.debian.version }}:cloud
          build-args: |
            BASE_IMAGE=debian:${{ matrix.debian.codename }}-slim
            PROJECT_NAME=test-debian-${{ matrix.debian.version }}
            PROJECT_PATH=.
            INCLUDE_KUBERNETES=true
            INCLUDE_TERRAFORM=true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify cloud tools installation
        run: |
          docker run --rm test-debian-${{ matrix.debian.version }}:cloud kubectl version --client
          docker run --rm test-debian-${{ matrix.debian.version }}:cloud terraform version

  # =====================================
  # Security Scanning
  # =====================================
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: read
      security-events: write
    strategy:
      matrix:
        # =====================================================
        # VARIANT FEATURE TOGGLE (for debugging/development)
        # =====================================================
        # Subset of variants for security scanning:
        # - minimal: Base image security posture
        # - cloud-ops: Cloud tools (K8s, Terraform, cloud CLIs)
        # Note: polyglot excluded - too large for Trivy timeout.
        # Production security scans should run in consuming apps.
        # =====================================================
        variant: [minimal, cloud-ops]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare sanitized tag
        id: tag
        run: |
          # Sanitize branch name (replace / with -) to match docker/metadata-action behavior
          TAG_NAME="${{ github.ref_name }}"
          TAG_NAME="${TAG_NAME//\//-}"
          echo "sanitized=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Pull image for scanning
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.sanitized }}-${{ matrix.variant }}

      - name: Free up disk space for large image scanning
        run: |
          # Remove unnecessary tools to free space for Trivy to export large images
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /opt/hostedtoolcache/CodeQL
          sudo docker system prune -af --volumes
          # Re-pull the image after prune
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.sanitized }}-${{ matrix.variant }}
          df -h

      - name: Scan filesystem for misconfigurations
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'table'
          scanners: 'misconfig,secret'
          severity: 'CRITICAL,HIGH,MEDIUM'
          exit-code: '1'
        continue-on-error: true

      - name: Scan Dockerfile for issues
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: 'config'
          scan-ref: './Dockerfile'
          format: 'table'
          severity: 'CRITICAL,HIGH'
        continue-on-error: true

      - name: Run Trivy vulnerability scanner (CRITICAL - blocking)
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.sanitized }}-${{ matrix.variant }}
          format: 'table'
          scanners: 'vuln'
          severity: 'CRITICAL'
          exit-code: '1'
          ignore-unfixed: true
        # Critical vulnerabilities with fixes available will fail the build
        # Note: secrets are checked in filesystem scan with continue-on-error

      - name: Run Trivy vulnerability scanner (SARIF report)
        uses: aquasecurity/trivy-action@0.33.1
        if: always()
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.sanitized }}-${{ matrix.variant }}
          format: 'sarif'
          output: 'trivy-results-${{ matrix.variant }}.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v4
        if: always() && hashFiles(format('trivy-results-{0}.sarif', matrix.variant)) != ''
        with:
          sarif_file: 'trivy-results-${{ matrix.variant }}.sarif'
          category: 'container-${{ matrix.variant }}'

      - name: Generate SBOM
        uses: aquasecurity/trivy-action@0.33.1
        if: always()
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.sanitized }}-${{ matrix.variant }}
          format: 'cyclonedx'
          output: 'sbom-${{ matrix.variant }}.json'

      - name: Run Trivy for detailed report
        uses: aquasecurity/trivy-action@0.33.1
        if: always()
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.sanitized }}-${{ matrix.variant }}
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Upload Trivy scan results
        uses: actions/upload-artifact@v4
        if: always() && hashFiles(format('trivy-results-{0}.sarif', matrix.variant)) != ''
        with:
          name: trivy-results-${{ matrix.variant }}
          path: 'trivy-results-${{ matrix.variant }}.sarif'
          retention-days: 30

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        if: always() && hashFiles(format('sbom-{0}.json', matrix.variant)) != ''
        with:
          name: sbom-${{ matrix.variant }}
          path: 'sbom-${{ matrix.variant }}.json'
          retention-days: 90

  # =====================================
  # Performance Benchmarks
  # =====================================
  benchmark:
    name: Performance Benchmarks
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Run benchmarks
        id: benchmark
        run: |
          # Run benchmarks with JSON output
          ./tests/benchmarks/run-benchmark.sh --json > benchmark-results.json

          # Extract key metrics for summary
          echo "## Build Performance Metrics" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Variant | Build Time | Image Size | Layers | Cache Hit |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|------------|------------|--------|-----------|" >> $GITHUB_STEP_SUMMARY

          # Parse JSON and format table
          for variant in minimal python-dev node-dev golang-dev full; do
            time=$(jq -r ".results[] | select(.variant==\"$variant\") | .build_time_seconds // \"N/A\"" benchmark-results.json)
            size=$(jq -r ".results[] | select(.variant==\"$variant\") | .image_size_mb // \"N/A\"" benchmark-results.json)
            layers=$(jq -r ".results[] | select(.variant==\"$variant\") | .layer_count // \"N/A\"" benchmark-results.json)
            cache=$(jq -r ".results[] | select(.variant==\"$variant\") | .cache_hit_rate // \"N/A\"" benchmark-results.json)
            if [ "$time" != "N/A" ]; then
              printf "| %s | %.1fs | %.1f MB | %s | %.0f%% |\n" "$variant" "$time" "$size" "$layers" "$cache" >> $GITHUB_STEP_SUMMARY
            fi
          done

      - name: Upload benchmark results
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results
          path: benchmark-results.json
          retention-days: 90

      - name: Compare with baseline (if exists)
        continue-on-error: true
        run: |
          # Download previous benchmark if available
          if [ -f tests/benchmarks/results/baseline.json ]; then
            echo "## Performance Comparison" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            ./tests/benchmarks/compare-results.sh tests/benchmarks/results/baseline.json benchmark-results.json >> $GITHUB_STEP_SUMMARY || true
          fi

  # =====================================
  # Release Stage
  # =====================================
  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: build
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
      packages: write  # Required for Cosign to push signature blobs
      id-token: write  # Required for Cosign OIDC keyless signing
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Extract version from tag
        id: version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Generate image digests and sign with Cosign
        id: digests
        env:
          COSIGN_EXPERIMENTAL: 1  # Enable keyless signing
        run: |
          VERSION=${{ steps.version.outputs.VERSION }}

          # Generate digest file
          echo "# Container Image Digests for Release ${VERSION}" > image-digests.txt
          echo "" >> image-digests.txt
          echo "All images are cryptographically signed with Cosign (keyless OIDC)." >> image-digests.txt
          echo "Verify signatures with: \`cosign verify --certificate-identity-regexp='^https://github.com/${{ github.repository }}' --certificate-oidc-issuer=https://token.actions.githubusercontent.com <image>\`" >> image-digests.txt
          echo "" >> image-digests.txt

          # Process each variant
          for variant in minimal python-dev node-dev cloud-ops polyglot rust-golang; do
            IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION}-${variant}"
            echo "## ${variant}" >> image-digests.txt
            echo "Image: \`${IMAGE}\`" >> image-digests.txt

            # Get digest - use docker manifest inspect for proper digest extraction
            DIGEST=$(docker manifest inspect "${IMAGE}" | jq -r '.manifests[] | select(.platform.architecture == "amd64") | .digest')
            echo "Digest: \`${DIGEST}\`" >> image-digests.txt

            # Sign with Cosign
            echo "Signing ${IMAGE}..."
            cosign sign --yes "${IMAGE}@${DIGEST}"

            echo "" >> image-digests.txt
          done

          echo "Image digests generated and all images signed successfully"

      - name: Generate release notes
        id: notes
        run: |
          VERSION=${{ steps.version.outputs.VERSION }}
          cat > release-notes.md << EOF
          ## Container Build System Release ${VERSION}

          ### Available Images
          - \`ghcr.io/${{ github.repository }}:minimal-${VERSION}\` - Minimal base container
          - \`ghcr.io/${{ github.repository }}:python-dev-${VERSION}\` - Python development environment
          - \`ghcr.io/${{ github.repository }}:node-dev-${VERSION}\` - Node.js development environment
          - \`ghcr.io/${{ github.repository }}:cloud-ops-${VERSION}\` - Cloud operations tools
          - \`ghcr.io/${{ github.repository }}:polyglot-${VERSION}\` - Multi-language environment
          - \`ghcr.io/${{ github.repository }}:rust-golang-${VERSION}\` - Rust + Go development

          ### Usage
          \`\`\`bash
          docker pull ghcr.io/${{ github.repository }}:python-dev-${VERSION}
          docker run -it --rm ghcr.io/${{ github.repository }}:python-dev-${VERSION}
          \`\`\`

          ### Security: Image Signatures & Digests
          All container images are cryptographically signed with [Cosign](https://github.com/sigstore/cosign) using keyless OIDC signing.

          **Verify image signatures:**
          \`\`\`bash
          cosign verify \\
            --certificate-identity-regexp='^https://github.com/${{ github.repository }}' \\
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com \\
            ghcr.io/${{ github.repository }}:python-dev-${VERSION}
          \`\`\`

          **Image digests:** See \`image-digests.txt\` in release assets for SHA256 digests of all images.

          ### What's Changed
          See [CHANGELOG.md](CHANGELOG.md) for detailed changes.

          ### Using as Git Submodule
          \`\`\`bash
          git submodule add https://github.com/${{ github.repository }}.git containers
          git submodule update --init --checkout --remote --reference ${VERSION}
          \`\`\`
          EOF

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          body_path: release-notes.md
          draft: false
          prerelease: false
          token: ${{ secrets.GITHUB_TOKEN }}
