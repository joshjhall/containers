name: Automated Patch Releases

on:
  schedule:
    # Weekly version check - Sundays at 2am UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types: [completed]
    branches: ['auto-patch/**']

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # =====================================
  # Scheduled Version Check
  # =====================================
  version-check:
    name: Check Versions and Create Patch Branch
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history needed for git-cliff changelog generation
          token: ${{ secrets.AUTO_PATCH_TOKEN }}

      - name: Check for version updates
        id: check
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Checking for version updates..."
          OUTPUT=$(./bin/check-versions.sh --json 2>&1 || true)

          # Save output for update script
          echo "$OUTPUT" > /tmp/version-check-output.json

          # Validate JSON output
          if ! echo "$OUTPUT" | jq empty 2>/dev/null; then
            echo "ERROR: Version check did not return valid JSON"
            exit 1
          fi

          # Check for outdated tools
          OUTDATED=$(echo "$OUTPUT" | jq '[.tools[] | select(.status == "outdated")]')
          UPDATE_COUNT=$(echo "$OUTDATED" | jq 'length')

          if [ "$UPDATE_COUNT" -gt 0 ]; then
            echo "Found $UPDATE_COUNT version update(s)"
            echo "$OUTDATED" | jq '.'
            echo "has_updates=true" >> $GITHUB_OUTPUT

            # Create summary for notification
            SUMMARY=""
            while IFS= read -r tool; do
              TOOL_NAME=$(echo "$tool" | jq -r '.tool')
              CURRENT=$(echo "$tool" | jq -r '.current')
              LATEST=$(echo "$tool" | jq -r '.latest')
              SUMMARY="${SUMMARY}‚Ä¢ ${TOOL_NAME}: ${CURRENT} ‚Üí ${LATEST}\n"
            done < <(echo "$OUTDATED" | jq -c '.[]')

            # Save for commit message and notifications
            echo "updates_summary<<EOF" >> $GITHUB_OUTPUT
            echo -e "$SUMMARY" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "All versions are up to date!"
            echo "has_updates=false" >> $GITHUB_OUTPUT
          fi

          # Check for cargo-release update (pinned due to upstream bug)
          CARGO_RELEASE_UPDATE=$(echo "$OUTPUT" | jq -r '.tools[] | select(.tool == "cargo-release" and .status == "outdated") | .latest // empty' 2>/dev/null || true)
          if [ -n "$CARGO_RELEASE_UPDATE" ]; then
            echo "cargo_release_update=$CARGO_RELEASE_UPDATE" >> $GITHUB_OUTPUT
          fi

      - name: Notify cargo-release update available
        if: steps.check.outputs.cargo_release_update != ''
        run: |
          # cargo-release is pinned to 0.25.21 due to upstream bug
          # Notify when new version available so we can check if bug is fixed
          curl -s \
            --form-string "token=${{ secrets.PUSHOVER_TOKEN }}" \
            --form-string "user=${{ secrets.PUSHOVER_USER }}" \
            --form-string "title=ü¶Ä cargo-release update available" \
            --form-string "message=cargo-release ${{ steps.check.outputs.cargo_release_update }} is now available.

          Currently pinned to 0.25.21 due to trycmd/toml_edit bug.

          Check if upstream issue is fixed:
          https://github.com/crate-ci/cargo-release/issues

          If fixed, update rust-dev.sh to remove version pin." \
            --form-string "priority=0" \
            --form-string "sound=pushover" \
            https://api.pushover.net/1/messages.json

      - name: Create auto-patch branch and apply updates
        if: steps.check.outputs.has_updates == 'true'
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create branch name with timestamp
          BRANCH_NAME="auto-patch/$(date +%Y%m%d-%H%M%S)"
          echo "Creating branch: $BRANCH_NAME"

          # Create and checkout new branch
          git checkout -b "$BRANCH_NAME"

          # Apply version updates
          echo "Applying version updates..."
          ./bin/update-versions.sh --input /tmp/version-check-output.json --no-commit --no-bump

          # Update checksums for new versions
          echo "Updating pinned checksums..."
          ./bin/update-checksums.sh || {
            echo "Warning: Checksum updates failed, continuing anyway"
          }

          # Update version compatibility matrix with new versions
          echo "Updating version compatibility matrix..."
          if [ -f "version-compatibility-matrix.json" ]; then
            # Extract current versions from Dockerfile
            PYTHON_VER=$(grep "^ARG PYTHON_VERSION=" Dockerfile | cut -d= -f2 | tr -d '"')
            NODE_VER=$(grep "^ARG NODE_VERSION=" Dockerfile | cut -d= -f2 | tr -d '"')
            RUST_VER=$(grep "^ARG RUST_VERSION=" Dockerfile | cut -d= -f2 | tr -d '"')
            GO_VER=$(grep "^ARG GO_VERSION=" Dockerfile | cut -d= -f2 | tr -d '"')
            RUBY_VER=$(grep "^ARG RUBY_VERSION=" Dockerfile | cut -d= -f2 | tr -d '"')
            JAVA_VER=$(grep "^ARG JAVA_VERSION=" Dockerfile | cut -d= -f2 | tr -d '"')
            R_VER=$(grep "^ARG R_VERSION=" Dockerfile | cut -d= -f2 | tr -d '"')

            # Update the matrix with current versions
            jq \
              --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              --arg python "${PYTHON_VER:-}" \
              --arg node "${NODE_VER:-}" \
              --arg rust "${RUST_VER:-}" \
              --arg go "${GO_VER:-}" \
              --arg ruby "${RUBY_VER:-}" \
              --arg java "${JAVA_VER:-}" \
              --arg r "${R_VER:-}" \
              '
              .last_updated = $timestamp |
              (if $python != "" then .language_versions.python.current = $python else . end) |
              (if $node != "" then .language_versions.node.current = $node else . end) |
              (if $rust != "" then .language_versions.rust.current = $rust else . end) |
              (if $go != "" then .language_versions.go.current = $go else . end) |
              (if $ruby != "" then .language_versions.ruby.current = $ruby else . end) |
              (if $java != "" then .language_versions.java.current = $java else . end) |
              (if $r != "" then .language_versions.r.current = $r else . end)
              ' version-compatibility-matrix.json > version-compatibility-matrix.json.tmp \
              && mv version-compatibility-matrix.json.tmp version-compatibility-matrix.json
            echo "Version compatibility matrix updated"
          else
            echo "Warning: version-compatibility-matrix.json not found"
          fi

          # Update GPG keys (check for changes)
          echo "Checking for GPG key updates..."
          git diff --quiet lib/gpg-keys/ || echo "HAS_EXISTING_CHANGES=true" >> $GITHUB_ENV

          ./bin/update-gpg-keys.sh all || {
            echo "Warning: GPG key updates failed, continuing anyway"
          }

          # Detect if actual GPG key files changed (not just metadata or whitespace)
          # Only alert on .asc files and keyring/* contents, ignore metadata JSON and README
          # Use --ignore-space-change to skip whitespace-only diffs (e.g., trailing newlines)
          KEY_FILES_CHANGED=$(git diff --ignore-space-change --name-only lib/gpg-keys/ | grep -E '\.(asc|kbx|gpg)$' || true)

          if [ -z "$KEY_FILES_CHANGED" ]; then
            echo "No GPG key file changes detected (metadata and whitespace-only changes are ignored)"
            echo "gpg_keys_changed=false" >> $GITHUB_ENV
          else
            echo "GPG key file changes detected!"
            echo "$KEY_FILES_CHANGED"
            echo "gpg_keys_changed=true" >> $GITHUB_ENV

            # Capture detailed changes for notification (only key files)
            GPG_CHANGES=$(git diff --stat $KEY_FILES_CHANGED | head -20)
            echo "GPG_CHANGES<<EOF" >> $GITHUB_ENV
            echo "$GPG_CHANGES" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV

            # Get more detailed change summary
            GPG_DETAIL=$(git diff $KEY_FILES_CHANGED | grep -E '^\+\+\+|^---|\+.*fingerprint|\+.*Key ID' | head -30)
            echo "GPG_DETAIL<<EOF" >> $GITHUB_ENV
            echo "$GPG_DETAIL" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          fi

          # Bump patch version
          echo "Bumping patch version..."
          echo "y" | ./bin/release.sh patch

          # Get the new version for tagging
          NEW_VERSION=$(cat VERSION)
          echo "new_version=$NEW_VERSION" >> $GITHUB_ENV
          echo "New version: $NEW_VERSION"

          # Commit changes
          cat > /tmp/commit-message.txt << EOF
          chore: automated version updates to v${NEW_VERSION}

          Version updates detected and applied:

          ${{ steps.check.outputs.updates_summary }}

          Bumped version: ${NEW_VERSION}
          EOF

          # Add GPG key changes to commit message if detected
          if [ "${{ env.gpg_keys_changed }}" = "true" ]; then
            cat >> /tmp/commit-message.txt << 'EOF'

          ‚ö†Ô∏è GPG Key Changes Detected:

          ${{ env.GPG_CHANGES }}

          Review the changes carefully before merging.
          EOF
          fi

          cat >> /tmp/commit-message.txt << 'EOF'

          This is an automated patch release. CI will validate these changes
          and automatically merge if all tests pass.

          ü§ñ Generated with automated patch release system
          EOF

          git add -A
          git commit -F /tmp/commit-message.txt

          # Push branch (this triggers CI)
          git push origin "$BRANCH_NAME"

          # Save branch name for potential use
          echo "PATCH_BRANCH=$BRANCH_NAME" >> $GITHUB_ENV

      - name: Send CRITICAL notification for GPG key changes
        if: env.gpg_keys_changed == 'true'
        run: |
          # Build detailed notification message
          NOTIFICATION_MSG="üîê CRITICAL: GPG Signing Key Changes Detected

          Branch: ${{ env.PATCH_BRANCH }}
          Version: ${{ env.new_version }}

          SECURITY REVIEW REQUIRED

          Files changed:
          ${{ env.GPG_CHANGES }}

          Key details:
          ${{ env.GPG_DETAIL }}

          ‚ö†Ô∏è Action Required:
          1. Review the changes at: ${{ github.server_url }}/${{ github.repository }}/tree/${{ env.PATCH_BRANCH }}
          2. Verify fingerprints match official sources
          3. Check timing - did you expect this key change?
          4. Look for anomalies (unexpected keys, wrong fingerprints, suspicious timing)

          This is RARE - GPG keys typically don't change often.
          If this seems unexpected, investigate immediately.

          Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # Send CRITICAL priority notification
          curl -s \
            --form-string "token=${{ secrets.PUSHOVER_TOKEN }}" \
            --form-string "user=${{ secrets.PUSHOVER_USER }}" \
            --form-string "title=üîê CRITICAL: GPG Key Changes" \
            --form-string "message=$NOTIFICATION_MSG" \
            --form-string "priority=2" \
            --form-string "retry=300" \
            --form-string "expire=3600" \
            --form-string "sound=siren" \
            https://api.pushover.net/1/messages.json

      - name: Send version-check failure notification
        if: failure()
        run: |
          # Get context about what failed
          ERROR_MSG="Version check or branch creation failed during automated patch release.

          Workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          This requires manual investigation."

          # Send notification
          curl -s \
            --form-string "token=${{ secrets.PUSHOVER_TOKEN }}" \
            --form-string "user=${{ secrets.PUSHOVER_USER }}" \
            --form-string "title=‚ùå Auto-Patch Version Check Failed" \
            --form-string "message=$ERROR_MSG" \
            --form-string "priority=1" \
            --form-string "sound=persistent" \
            https://api.pushover.net/1/messages.json

  # =====================================
  # Auto-Merge After CI Success
  # =====================================
  auto-merge:
    name: Auto-Merge Patch Release
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_run' &&
      github.event.workflow_run.conclusion == 'success' &&
      startsWith(github.event.workflow_run.head_branch, 'auto-patch/')
    permissions:
      contents: write
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.AUTO_PATCH_TOKEN }}

      - name: Get patch branch info
        id: branch_info
        run: |
          BRANCH_NAME="${{ github.event.workflow_run.head_branch }}"
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

          # Extract version changes from the branch
          git fetch origin "$BRANCH_NAME"
          git checkout "$BRANCH_NAME"

          # Get current version from VERSION file
          CURRENT_VERSION=$(cat VERSION)
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Get commit message for notification
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "commit_message<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MSG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update compatibility matrix with test results
        run: |
          echo "Updating compatibility matrix with passing test results..."
          if [ -f "version-compatibility-matrix.json" ]; then
            # Extract current versions from Dockerfile
            PYTHON_VER=$(grep "^ARG PYTHON_VERSION=" Dockerfile | cut -d= -f2 | tr -d '"')
            NODE_VER=$(grep "^ARG NODE_VERSION=" Dockerfile | cut -d= -f2 | tr -d '"')
            RUST_VER=$(grep "^ARG RUST_VERSION=" Dockerfile | cut -d= -f2 | tr -d '"')
            GO_VER=$(grep "^ARG GO_VERSION=" Dockerfile | cut -d= -f2 | tr -d '"')
            RUBY_VER=$(grep "^ARG RUBY_VERSION=" Dockerfile | cut -d= -f2 | tr -d '"')
            JAVA_VER=$(grep "^ARG JAVA_VERSION=" Dockerfile | cut -d= -f2 | tr -d '"')
            R_VER=$(grep "^ARG R_VERSION=" Dockerfile | cut -d= -f2 | tr -d '"')

            # Update tested_combinations status to passing and update tested arrays
            jq \
              --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              --arg python "${PYTHON_VER:-}" \
              --arg node "${NODE_VER:-}" \
              --arg rust "${RUST_VER:-}" \
              --arg go "${GO_VER:-}" \
              --arg ruby "${RUBY_VER:-}" \
              --arg java "${JAVA_VER:-}" \
              --arg r "${R_VER:-}" \
              '
              .last_updated = $timestamp |
              # Update all tested_combinations to passing with current timestamp
              .tested_combinations = [
                .tested_combinations[] |
                .status = "passing" |
                .tested_at = $timestamp |
                # Update versions in tested combinations
                if .variant == "python-dev" and $python != "" then .versions.python = $python
                elif .variant == "node-dev" and $node != "" then .versions.node = $node
                elif .variant == "rust-golang" and $rust != "" and $go != "" then .versions.rust = $rust | .versions.go = $go
                elif .variant == "polyglot" then
                  (if $python != "" then .versions.python = $python else . end) |
                  (if $node != "" then .versions.node = $node else . end) |
                  (if $rust != "" then .versions.rust = $rust else . end) |
                  (if $go != "" then .versions.go = $go else . end)
                else .
                end
              ] |
              # Update tested arrays in language_versions
              (if $python != "" and (.language_versions.python.tested | index($python) | not) then
                .language_versions.python.tested += [$python]
              else . end) |
              (if $node != "" and (.language_versions.node.tested | index($node) | not) then
                .language_versions.node.tested += [$node]
              else . end) |
              (if $rust != "" and (.language_versions.rust.tested | index($rust) | not) then
                .language_versions.rust.tested += [$rust]
              else . end) |
              (if $go != "" and (.language_versions.go.tested | index($go) | not) then
                .language_versions.go.tested += [$go]
              else . end) |
              (if $ruby != "" and (.language_versions.ruby.tested | index($ruby) | not) then
                .language_versions.ruby.tested += [$ruby]
              else . end) |
              (if $java != "" and (.language_versions.java.tested | index($java) | not) then
                .language_versions.java.tested += [$java]
              else . end) |
              (if $r != "" and (.language_versions.r.tested | index($r) | not) then
                .language_versions.r.tested += [$r]
              else . end)
              ' version-compatibility-matrix.json > version-compatibility-matrix.json.tmp \
              && mv version-compatibility-matrix.json.tmp version-compatibility-matrix.json

            # Commit the matrix update
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add version-compatibility-matrix.json
            git commit -m "chore: Update compatibility matrix with passing test results" || echo "No matrix changes to commit"
            echo "Compatibility matrix updated with test results"
          else
            echo "Warning: version-compatibility-matrix.json not found"
          fi

      - name: Merge to main
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Checkout main and merge
          git checkout main
          git merge --no-ff "${{ steps.branch_info.outputs.branch }}" -m "Merge automated patch release: ${{ steps.branch_info.outputs.branch }}"

          # Push to main
          git push origin main

      - name: Create and push version tag
        run: |
          VERSION="${{ steps.branch_info.outputs.version }}"
          git tag -a "v${VERSION}" -m "Automated patch release v${VERSION}"
          git push origin "v${VERSION}"

          echo "Tag pushed. CI workflow will create GitHub release automatically."

      - name: Delete auto-patch branch
        run: |
          git push origin --delete "${{ steps.branch_info.outputs.branch }}"

      - name: Send success notification
        if: success()
        run: |
          VERSION="${{ steps.branch_info.outputs.version }}"

          curl -s \
            --form-string "token=${{ secrets.PUSHOVER_TOKEN }}" \
            --form-string "user=${{ secrets.PUSHOVER_USER }}" \
            --form-string "title=‚úÖ Patch Release v${VERSION} Deployed" \
            --form-string "message=Automated patch release succeeded:

          Version: v${VERSION}
          Branch: ${{ steps.branch_info.outputs.branch }}

          Changes:
          ${{ steps.branch_info.outputs.commit_message }}

          All tests passed and changes have been merged to main." \
            --form-string "priority=0" \
            --form-string "sound=pushover" \
            https://api.pushover.net/1/messages.json

      - name: Send failure notification
        if: failure()
        run: |
          VERSION="${{ steps.branch_info.outputs.version }}"

          curl -s \
            --form-string "token=${{ secrets.PUSHOVER_TOKEN }}" \
            --form-string "user=${{ secrets.PUSHOVER_USER }}" \
            --form-string "title=‚ùå Patch Release v${VERSION} Failed" \
            --form-string "message=Automated patch release failed during merge:

          Version: v${VERSION}
          Branch: ${{ steps.branch_info.outputs.branch }}

          The branch has been preserved for manual review.

          Check workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --form-string "priority=1" \
            --form-string "sound=persistent" \
            https://api.pushover.net/1/messages.json

  # =====================================
  # Notify CI Failure
  # =====================================
  ci-failure:
    name: Notify CI Failure on Patch Branch
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_run' &&
      github.event.workflow_run.conclusion == 'failure' &&
      startsWith(github.event.workflow_run.head_branch, 'auto-patch/')
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_branch }}

      - name: Get version and changes
        id: info
        run: |
          BRANCH_NAME="${{ github.event.workflow_run.head_branch }}"
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

          # Get current version from VERSION file
          CURRENT_VERSION=$(cat VERSION)
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Get commit message
          COMMIT_MSG=$(git log -1 --pretty=%B | head -n 20)
          echo "commit_message<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MSG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Send failure notification
        run: |
          VERSION="${{ steps.info.outputs.version }}"

          curl -s \
            --form-string "token=${{ secrets.PUSHOVER_TOKEN }}" \
            --form-string "user=${{ secrets.PUSHOVER_USER }}" \
            --form-string "title=‚ö†Ô∏è Patch Release v${VERSION} CI Failed" \
            --form-string "message=Automated patch release failed CI validation:

          Version: v${VERSION}
          Branch: ${{ steps.info.outputs.branch }}

          Changes attempted:
          ${{ steps.info.outputs.commit_message }}

          CI tests failed. Branch preserved for manual review.

          Workflow: ${{ github.event.workflow_run.html_url }}
          Branch: ${{ github.server_url }}/${{ github.repository }}/tree/${{ steps.info.outputs.branch }}" \
            --form-string "priority=1" \
            --form-string "sound=persistent" \
            https://api.pushover.net/1/messages.json
