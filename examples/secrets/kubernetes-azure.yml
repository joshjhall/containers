# Kubernetes Example: Azure Key Vault with Pod Identity
#
# This example demonstrates using Azure Key Vault with AAD Pod Identity
# on Azure Kubernetes Service (AKS).
#
# Prerequisites:
#   1. AKS cluster with AAD Pod Identity enabled
#   2. Azure Key Vault with secrets
#   3. Managed Identity with Key Vault access
#
# Setup:
#   # Create managed identity
#   az identity create -g myResourceGroup -n myapp-identity
#
#   # Assign Key Vault permissions
#   az keyvault set-policy \
#     --name myapp-keyvault \
#     --object-id <identity-principal-id> \
#     --secret-permissions get list
#
#   # Create AzureIdentity and AzureIdentityBinding
#   # (see resources below)

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: myapp
  namespace: default

---
apiVersion: aadpodidentity.k8s.io/v1
kind: AzureIdentity
metadata:
  name: myapp-identity
  namespace: default
spec:
  type: 0 # User-assigned managed identity
  resourceID: /subscriptions/<subscription-id>/resourcegroups/myResourceGroup/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myapp-identity
  clientID: <managed-identity-client-id>

---
apiVersion: aadpodidentity.k8s.io/v1
kind: AzureIdentityBinding
metadata:
  name: myapp-identity-binding
  namespace: default
spec:
  azureIdentity: myapp-identity
  selector: myapp-identity

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: myapp-azure-config
  namespace: default
data:
  AZURE_KEYVAULT_NAME: "myapp-keyvault"
  AZURE_SECRET_NAMES: "database-password,api-key,encryption-key"
  AZURE_SECRET_PREFIX: "APP_"

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
        aadpodidbinding: myapp-identity # Matches AzureIdentityBinding selector
    spec:
      serviceAccountName: myapp
      containers:
        - name: app
          image: myapp:latest
          env:
            # Enable Azure Key Vault integration
            - name: AZURE_KEYVAULT_ENABLED
              value: "true"

            # Universal loader configuration
            - name: SECRET_LOADER_ENABLED
              value: "true"
            - name: SECRET_LOADER_PRIORITY
              value: "azure"
            - name: SECRET_LOADER_FAIL_ON_ERROR
              value: "true"

          # Azure configuration from ConfigMap
          envFrom:
            - configMapRef:
                name: myapp-azure-config

          ports:
            - containerPort: 8080
              name: http

          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "500m"

---
# Alternative: Using Workload Identity (AKS 1.22+)
# More modern approach than AAD Pod Identity
#
# Setup:
#   # Enable workload identity on cluster
#   az aks update -g myResourceGroup -n myCluster --enable-workload-identity
#
#   # Create service account with workload identity annotation
#   # (see below)
#
# apiVersion: v1
# kind: ServiceAccount
# metadata:
#   name: myapp
#   namespace: default
#   annotations:
#     azure.workload.identity/client-id: <managed-identity-client-id>
#
# # Update deployment pod template with workload identity label
# spec:
#   template:
#     metadata:
#       labels:
#         azure.workload.identity/use: "true"
